# App Realtime Ext

[![style: very good analysis][very_good_analysis_badge]][very_good_analysis_link]
[![Powered by Mason](https://img.shields.io/endpoint?url=https%3A%2F%2Ftinyurl.com%2Fmason-badge)](https://github.com/felangel/mason)
[![License: MIT][license_badge]][license_link]

A Realtime Clone from Appwrite Flutter sdk. The purpose of this is to extend the capability and separate from sdk-generator

## Installation üíª

**‚ùó In order to start using App Realtime Ext you must have the [Flutter SDK][flutter_install_link] installed on your machine.**

Install via `flutter pub add`:

```sh
dart pub add app_realtime_ext
```

---

## Continuous Integration ü§ñ

App Realtime Ext comes with a built-in [GitHub Actions workflow][github_actions_link] powered by [Very Good Workflows][very_good_workflows_link] but you can also add your preferred CI/CD solution.

Out of the box, on each pull request and push, the CI `formats`, `lints`, and `tests` the code. This ensures the code remains consistent and behaves correctly as you add functionality or make changes. The project uses [Very Good Analysis][very_good_analysis_link] for a strict set of analysis options used by our team. Code coverage is enforced using the [Very Good Workflows][very_good_coverage_link].

---

## Running Tests üß™

For first time users, install the [very_good_cli][very_good_cli_link]:

```sh
dart pub global activate very_good_cli
```

To run all unit tests:

```sh
very_good test --coverage
```

To view the generated coverage report you can use [lcov](https://github.com/linux-test-project/lcov).

```sh
# Generate Coverage Report
genhtml coverage/lcov.info -o coverage/

# Open Coverage Report
open coverage/index.html
```

[flutter_install_link]: https://docs.flutter.dev/get-started/install
[github_actions_link]: https://docs.github.com/en/actions/learn-github-actions
[license_badge]: https://img.shields.io/badge/license-MIT-blue.svg
[license_link]: https://opensource.org/licenses/MIT
[logo_black]: https://raw.githubusercontent.com/VGVentures/very_good_brand/main/styles/README/vgv_logo_black.png#gh-light-mode-only
[logo_white]: https://raw.githubusercontent.com/VGVentures/very_good_brand/main/styles/README/vgv_logo_white.png#gh-dark-mode-only
[mason_link]: https://github.com/felangel/mason
[very_good_analysis_badge]: https://img.shields.io/badge/style-very_good_analysis-B22C89.svg
[very_good_analysis_link]: https://pub.dev/packages/very_good_analysis
[very_good_cli_link]: https://pub.dev/packages/very_good_cli
[very_good_coverage_link]: https://github.com/marketplace/actions/very-good-coverage
[very_good_ventures_link]: https://verygood.ventures
[very_good_ventures_link_light]: https://verygood.ventures#gh-light-mode-only
[very_good_ventures_link_dark]: https://verygood.ventures#gh-dark-mode-only
[very_good_workflows_link]: https://github.com/VeryGoodOpenSource/very_good_workflows

<br>
<br>
<br>

# Why I created this package?

As I know, Appwrite Flutter SDK was generated by sdk-generator. It's a great tool to generate different SDKs for different languages. But, here is the problem. If we have to update some code in specific Appwrite SDK, it must be consistent with other SDKs. So, I decided to create this package by cloning and get only the Realtime related code from Appwrite Flutter SDK. This package is not generated by sdk-generator. It's a manual process to get the Realtime related code from Appwrite Flutter SDK. And I will maintain this package to keep it up-to-date with Appwrite Flutter SDK. Another reason is that we can extend the capability of Appwrite Flutter SDK by adding more features to this package.
<br>
<br>
<br>

# How to use this package?

```dart
import 'package:app_realtime_ext/app_realtime_ext.dart';

final RealtimeExt realtime = RealtimeExt();
realtime.initialize(client: client);
```

> Note: `client` is an instance of `Client` from Appwrite Flutter SDK.

The `initialize` method has the following parameters:

- `client` (required): An instance of `Client` from Appwrite Flutter SDK.
- `retryAttempts` (optional): The number of retry attempts to connect to the server. Default is 3.
- `pingInterval` (optional): The interval between each retry attempt in milliseconds. Default is 30 seconds.
- `autoReconnect` (optional): Whether to automatically reconnect to the server when the connection is lost. Default is `true`. However, the `autoReconnect` will be stopped when it reaches the `retryAttempts`.
  <br>

You have to dispose the `realtime` object when you don't need it anymore.

```dart
realtime.dispose();
```

### What is `pingInterval`?

According to this site https://tools.ietf.org/html/rfc6455

> The WebSocket specification defines ping and pong message opcodes as part of the protocol. These can serve as a way to keep a connection active even if data is not being transmitted.
> Pings may be sent in either direction. If the client receives a ping, a pong reply will be automatically sent.

However, the Appwrite Websocket does not support two-way communication. So it is expected that the server will send you a message something like this. `"{"type":"error","data":{"code":1003,"message":"Message type is not valid."}}`. In this case, the package will automatically reconnect to the server. But the expected must be a pong message from the server. So, the `pingInterval` is the interval between each ping message to the server. If the server does not respond with a pong message, the package will automatically reconnect to the server. Hopefully, the Appwrite team will implement the pong message in the future.

## `stateStream` and `state`

The `stateStream` is a `Stream` that emits the `RealtimeState` of the websocket connection.

```dart
realtime.stateStream.listen((state) {
  print(state);
});

```

We have a different state in `RealtimeState` enum.

- `ConnectedState`: The websocket connection is connected.
- `DisconnectedState`: The websocket connection is disconnected.
- `ReconnectingState`: The websocket connection is reconnecting.
- `ErrorState`: The websocket connection is failed to connect.
- `SubscribedState`: The websocket connection is subscribed to a channel.
- `UnsubscribedState`: The websocket connection is unsubscribed from a channel.
- `PingState`: The websocket connection is sending a ping message to the server.
- `DisposingState`: The websocket connection is disposing.

To use that:

```dart
realtime.stateStream.listen((state) {
    if(state is ErrorState){
        showErrorDialog();
    }
});

```

The `state` is a getter that returns the current `RealtimeState` of the websocket connection.

```dart
print(realtime.state);
```

## `getConnectionCompleter`

The `getConnectionCompleter` is a `Completer` that completes when the websocket connection is connected. It can be used if you are trying to create new document. But you have to check first if the websocket connection is connected.

```dart
Future<void> doSomething() async{
    isLoading = true;
    await realtime.getConnectionCompleter.future;
    await createDocument();
}
```

### `reconnect`

You can manually reconnect to the server by calling the `reconnect` method.

```dart
realtime.reconnect();
```

---

## Contribute to Realtime Extension for Appwrite Flutter

We're always looking for contributions to help improve the Realtime feature in the Appwrite Flutter SDK or if you want to add more features to this package. If you have ideas, bug reports, or enhancements, please feel free to help us by:

- **Submitting a Pull Request**: If you have a specific improvement or bug fix, submit a pull request with your changes.
- **Opening an Issue**: For ideas, feedback, or found bugs, open an issue in our GitHub repository.
- **Joining the Discussion**: Participate in discussions in our GitHub issues or our community chat to help shape the future of Realtime in Appwrite Flutter.

Your contributions are highly appreciated!
